// -----------------------------------------------------------------------------
// This file was autogenerated by symforce from template:
//     function/FUNCTION.h.jinja
// Do NOT modify by hand.
// -----------------------------------------------------------------------------

#pragma once

#include <Eigen/Core>

namespace sym {

/**
 * This function was autogenerated from a symbolic function. Do not modify by hand.
 *
 * Symbolic function: calc_p_ecef
 *
 * Args:
 *     Pi: Matrix31
 *     Vi: Matrix31
 *     Pj: Matrix31
 *     Vj: Matrix31
 *     rcv_dt: Scalar
 *     rcv_ddt: Scalar
 *     yaw_diff: Scalar
 *     ref_ecef: Matrix31
 *     ratio: Scalar
 *     epsilon: Scalar
 *
 * Outputs:
 *     res: Matrix31
 */
template <typename Scalar>
Eigen::Matrix<Scalar, 3, 1> CalcPEcef(const Eigen::Matrix<Scalar, 3, 1>& Pi,
                                      const Eigen::Matrix<Scalar, 3, 1>& Vi,
                                      const Eigen::Matrix<Scalar, 3, 1>& Pj,
                                      const Eigen::Matrix<Scalar, 3, 1>& Vj, const Scalar rcv_dt,
                                      const Scalar rcv_ddt, const Scalar yaw_diff,
                                      const Eigen::Matrix<Scalar, 3, 1>& ref_ecef,
                                      const Scalar ratio, const Scalar epsilon) {
  // Total ops: 85

  // Unused inputs
  (void)Vi;
  (void)Vj;
  (void)rcv_dt;
  (void)rcv_ddt;

  // Input arrays

  // Intermediate terms (19)
  const Scalar _tmp0 =
      Scalar(1.0) *
      std::atan2(ref_ecef(1, 0),
                 epsilon * ((((ref_ecef(0, 0)) > 0) - ((ref_ecef(0, 0)) < 0)) + Scalar(0.5)) +
                     ref_ecef(0, 0));
  const Scalar _tmp1 = std::cos(_tmp0);
  const Scalar _tmp2 = Scalar(1.0) - ratio;
  const Scalar _tmp3 = Pi(2, 0) * ratio + Pj(2, 0) * _tmp2;
  const Scalar _tmp4 =
      epsilon + std::pow(ref_ecef(0, 0), Scalar(2)) + std::pow(ref_ecef(1, 0), Scalar(2));
  const Scalar _tmp5 =
      (Scalar(1) / Scalar(259466641532452617353)) /
      (Scalar(0.99330562000986) * _tmp4 +
       (Scalar(1) / Scalar(40680631590769)) * std::pow(epsilon, Scalar(2)) +
       std::pow(ref_ecef(2, 0), Scalar(2)) *
           std::sqrt(Scalar(Scalar(0.99330562000986) * _tmp4 +
                            (Scalar(1) / Scalar(40680631590769)) * std::pow(epsilon, Scalar(2)) +
                            std::pow(ref_ecef(2, 0), Scalar(2)))));
  const Scalar _tmp6 =
      Scalar(1.0) * std::atan((Scalar(4.4917426690159599e+38) * _tmp5 *
                                   [&]() {
                                     const Scalar base = ref_ecef(2, 0);
                                     return base * base * base;
                                   }() /
                                   (epsilon + Scalar(40408299984661.5)) +
                               ref_ecef(2, 0)) /
                              (-Scalar(1.09675613733197e+25) * (_tmp4 * std::sqrt(_tmp4)) * _tmp5 +
                               std::sqrt(_tmp4) + epsilon));
  const Scalar _tmp7 = std::cos(_tmp6);
  const Scalar _tmp8 = _tmp3 * _tmp7;
  const Scalar _tmp9 = Pi(0, 0) * ratio + Pj(0, 0) * _tmp2;
  const Scalar _tmp10 = std::sin(_tmp6);
  const Scalar _tmp11 = std::sin(yaw_diff);
  const Scalar _tmp12 = _tmp1 * _tmp11;
  const Scalar _tmp13 = std::sin(_tmp0);
  const Scalar _tmp14 = std::cos(yaw_diff);
  const Scalar _tmp15 = _tmp13 * _tmp14;
  const Scalar _tmp16 = Pi(1, 0) * ratio + Pj(1, 0) * _tmp2;
  const Scalar _tmp17 = _tmp1 * _tmp14;
  const Scalar _tmp18 = _tmp11 * _tmp13;

  // Output terms (1)
  Eigen::Matrix<Scalar, 3, 1> _res;

  _res(0, 0) = _tmp1 * _tmp8 + _tmp16 * (-_tmp10 * _tmp17 + _tmp18) +
               _tmp9 * (-_tmp10 * _tmp12 - _tmp15) + ref_ecef(0, 0);
  _res(1, 0) = _tmp13 * _tmp8 + _tmp16 * (-_tmp10 * _tmp15 - _tmp12) +
               _tmp9 * (-_tmp10 * _tmp18 + _tmp17) + ref_ecef(1, 0);
  _res(2, 0) = _tmp10 * _tmp3 + _tmp11 * _tmp7 * _tmp9 + _tmp14 * _tmp16 * _tmp7 + ref_ecef(2, 0);

  return _res;
}  // NOLINT(readability/fn_size)

// NOLINTNEXTLINE(readability/fn_size)
}  // namespace sym
